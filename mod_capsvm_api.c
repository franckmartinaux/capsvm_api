/* 
**  mod_capsvm_api.c -- Apache sample capsvm_api module
**  [Autogenerated via ``apxs -n capsvm_api -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i -I /usr/include -L /usr/lib64 -l sqlite3 mod_capsvm_api.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /capsvm_api in as follows:
**
**    #   httpd.conf
**    LoadModule capsvm_api_module modules/mod_capsvm_api.so
**    <Location /capsvm_api>
**    SetHandler capsvm_api
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /capsvm_api and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/capsvm_api 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_capsvm_api.c
*/
#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "http_log.h"
#include "ap_config.h"
#include "apr_strings.h"
#include "sqlite3.h"
#include "mod_auth.h"
#include "http_request.h"
#include <crypt.h>

static char *db_path;

static int open_sqlite_db(sqlite3 **db) {
    int rc = sqlite3_open_v2(db_path, db, SQLITE_OPEN_READWRITE, NULL);
    if (rc != SQLITE_OK) {
        const char *err_msg = sqlite3_errmsg(*db);
        const char *err_str = sqlite3_errstr(rc);
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, "Can't open database: %s (%s)", err_msg, err_str);
        sqlite3_close(*db);
        *db = NULL;
        return HTTP_INTERNAL_SERVER_ERROR;
    }
    return OK;
}

static int close_sqlite_db(sqlite3 *db) {
    if (db) {
        sqlite3_close(db);
    }
    return OK;
}

static authn_status capsvm_check_password(request_rec *r, const char *user, const char *password) {
    sqlite3 *db;
    
    if (open_sqlite_db(&db) != OK) {
        return AUTH_GENERAL_ERROR;
    }

    const char *sql = "SELECT pw, groupname FROM users WHERE username = ?";
    sqlite3_stmt *stmt;
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) {
        const char *err_msg = sqlite3_errmsg(db);
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to prepare statement: %s", err_msg);
        close_sqlite_db(db);
        return AUTH_GENERAL_ERROR;
    }

    if (sqlite3_bind_text(stmt, 1, user, -1, SQLITE_STATIC) != SQLITE_OK) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to bind text");
        sqlite3_finalize(stmt);
        close_sqlite_db(db);
        return AUTH_GENERAL_ERROR;
    }

    if (sqlite3_step(stmt) != SQLITE_ROW) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "No such user");
        sqlite3_finalize(stmt);
        close_sqlite_db(db);
        return AUTH_USER_NOT_FOUND;
    }

    const unsigned char *db_groupname = sqlite3_column_text(stmt, 1);
    const unsigned char *db_hashed_password = sqlite3_column_text(stmt, 0);

    char *salt = strdup((const char *)db_hashed_password);
    char *hashed_password = crypt(password, salt);
    free(salt);

    if (hashed_password == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Error hashing password");
        sqlite3_finalize(stmt);
        close_sqlite_db(db);
        return AUTH_GENERAL_ERROR;
    }

    if (strcmp((const char *)db_hashed_password, hashed_password) != 0) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Incorrect password");
        sqlite3_finalize(stmt);
        close_sqlite_db(db);
        return AUTH_DENIED;
    }

    apr_table_set(r->notes, "user_groupname", (const char *)db_groupname);

    sqlite3_finalize(stmt);
    close_sqlite_db(db);
    return AUTH_GRANTED;
}

static int getgroup_handler(request_rec *r) {
    const char *groupname = apr_table_get(r->notes, "user_groupname");
    if (groupname == NULL) {
        groupname = "unknown";
    }

    ap_set_content_type(r, "text/plain");
    ap_rprintf(r, "%s", groupname);

    return OK;
}

static int adduser_handler(request_rec *r) {
    sqlite3 *db;
    if (open_sqlite_db(&db) != OK) {
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    apr_array_header_t *pairs;
    if (ap_parse_form_data(r, NULL, &pairs, -1, HUGE_STRING_LEN) != OK) {
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    const char *username = NULL;
    const char *password = NULL;
    const char *groupname = NULL;

    for (int i = 0; i < pairs->nelts; i++) {
        ap_form_pair_t *pair = &((ap_form_pair_t *)pairs->elts)[i];
        char *buffer = NULL;
        apr_off_t length; 

        apr_brigade_length(pair->value, 1, &length);  

        buffer = apr_palloc(r->pool, length + 1);
        if (buffer == NULL) {
            close_sqlite_db(db);
            return HTTP_INTERNAL_SERVER_ERROR;
        }

        apr_size_t size = (apr_size_t)length;

        if (apr_brigade_flatten(pair->value, buffer, &size) != APR_SUCCESS) {
            continue;
        }

        buffer[size] = '\0'; 

        if (strcmp(pair->name, "username") == 0) {
            username = apr_pstrdup(r->pool, buffer);
        } else if (strcmp(pair->name, "password") == 0) {
            password = apr_pstrdup(r->pool, buffer);
        } else if (strcmp(pair->name, "groupname") == 0) {
            groupname = apr_pstrdup(r->pool, buffer);
        }
    }

    if (username == NULL || password == NULL || groupname == NULL) {
        close_sqlite_db(db);
        return HTTP_BAD_REQUEST;
    }

    const char *sql = "INSERT INTO users (username, pw, groupname) VALUES (?, ?, ?)";
    sqlite3_stmt *stmt;
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, 0) != SQLITE_OK) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to prepare statement: %s", sqlite3_errmsg(db));
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (sqlite3_bind_text(stmt, 1, username, -1, SQLITE_STATIC) != SQLITE_OK ||
        sqlite3_bind_text(stmt, 2, password, -1, SQLITE_STATIC) != SQLITE_OK ||
        sqlite3_bind_text(stmt, 3, groupname, -1, SQLITE_STATIC) != SQLITE_OK) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to bind text: %s", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (sqlite3_step(stmt) != SQLITE_DONE) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to execute statement: %s", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    ap_set_content_type(r, "text/plain");
    ap_rprintf(r, "User %s added in the database", username);

    sqlite3_finalize(stmt);
    close_sqlite_db(db);
    return OK;
}

static int modifyuser_handler(request_rec *r) {
    sqlite3 *db;
    if (open_sqlite_db(&db) != OK) {
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    apr_array_header_t *pairs;
    if (ap_parse_form_data(r, NULL, &pairs, -1, HUGE_STRING_LEN) != OK) {
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    const char *username = NULL;
    const char *groupname = NULL;

    for (int i = 0; i < pairs->nelts; i++) {
        ap_form_pair_t *pair = &((ap_form_pair_t *)pairs->elts)[i];
        char *buffer = NULL;
        apr_off_t length;

        apr_brigade_length(pair->value, 1, &length);

        buffer = apr_palloc(r->pool, length + 1);
        if (buffer == NULL) {
            close_sqlite_db(db);
            return HTTP_INTERNAL_SERVER_ERROR;
        }

        apr_size_t size = (apr_size_t)length;

        if (apr_brigade_flatten(pair->value, buffer, &size) != APR_SUCCESS) {
            continue;
        }

        buffer[size] = '\0';

        if (strcmp(pair->name, "username") == 0) {
            username = apr_pstrdup(r->pool, buffer);
        } else if (strcmp(pair->name, "groupname") == 0) {
            groupname = apr_pstrdup(r->pool, buffer);
        }
    }

    if (username == NULL || groupname == NULL) {
        close_sqlite_db(db);
        return HTTP_BAD_REQUEST;
    }

    const char *check_sql = "SELECT 1 FROM users WHERE username = ?";
    sqlite3_stmt *check_stmt;
    if (sqlite3_prepare_v2(db, check_sql, -1, &check_stmt, 0) != SQLITE_OK) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to prepare check statement: %s", sqlite3_errmsg(db));
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (sqlite3_bind_text(check_stmt, 1, username, -1, SQLITE_STATIC) != SQLITE_OK) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to bind text for check statement: %s", sqlite3_errmsg(db));
        sqlite3_finalize(check_stmt);
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (sqlite3_step(check_stmt) != SQLITE_ROW) {
        ap_set_content_type(r, "text/plain");
        ap_rprintf(r, "User %s does not exist in the database", username);
        sqlite3_finalize(check_stmt);
        close_sqlite_db(db);
        return HTTP_NOT_FOUND;
    }

    const char *sql = "UPDATE users SET groupname = ? WHERE username = ?";
    sqlite3_stmt *stmt;
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, 0) != SQLITE_OK) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to prepare statement: %s", sqlite3_errmsg(db));
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (sqlite3_bind_text(stmt, 1, groupname, -1, SQLITE_STATIC) != SQLITE_OK ||
        sqlite3_bind_text(stmt, 2, username, -1, SQLITE_STATIC) != SQLITE_OK) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to bind text: %s", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (sqlite3_step(stmt) != SQLITE_DONE) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to execute statement: %s", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    ap_set_content_type(r, "text/plain");
    ap_rprintf(r, "User %s is now in the %s groupname", username, groupname);

    sqlite3_finalize(stmt);
    close_sqlite_db(db);
    return OK;
}


static int deleteuser_handler(request_rec *r) {
    sqlite3 *db;
    if (open_sqlite_db(&db) != OK) {
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    apr_array_header_t *pairs;
    if (ap_parse_form_data(r, NULL, &pairs, -1, HUGE_STRING_LEN) != OK) {
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    const char *username = NULL;

    for (int i = 0; i < pairs->nelts; i++) {
        ap_form_pair_t *pair = &((ap_form_pair_t *)pairs->elts)[i];
        char *buffer = NULL;
        apr_off_t length;

        apr_brigade_length(pair->value, 1, &length);

        buffer = apr_palloc(r->pool, length + 1);
        if (buffer == NULL) {
            close_sqlite_db(db);
            return HTTP_INTERNAL_SERVER_ERROR;
        }

        apr_size_t size = (apr_size_t)length;

        if (apr_brigade_flatten(pair->value, buffer, &size) != APR_SUCCESS) {
            continue;
        }

        buffer[size] = '\0';

        if (strcmp(pair->name, "username") == 0) {
            username = apr_pstrdup(r->pool, buffer);
        }
    }

    if (username == NULL) {
        close_sqlite_db(db);
        return HTTP_BAD_REQUEST;
    }

    const char *check_sql = "SELECT 1 FROM users WHERE username = ?";
    sqlite3_stmt *check_stmt;
    if (sqlite3_prepare_v2(db, check_sql, -1, &check_stmt, 0) != SQLITE_OK) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to prepare check statement: %s", sqlite3_errmsg(db));
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (sqlite3_bind_text(check_stmt, 1, username, -1, SQLITE_STATIC) != SQLITE_OK) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to bind text for check statement: %s", sqlite3_errmsg(db));
        sqlite3_finalize(check_stmt);
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (sqlite3_step(check_stmt) != SQLITE_ROW) {
        ap_set_content_type(r, "text/plain");
        ap_rprintf(r, "User %s does not exist in the database", username);
        sqlite3_finalize(check_stmt);
        close_sqlite_db(db);
        return HTTP_NOT_FOUND;
    }

    const char *sql = "DELETE FROM users WHERE username = ?";
    sqlite3_stmt *stmt;
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, 0) != SQLITE_OK) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to prepare statement: %s", sqlite3_errmsg(db));
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (sqlite3_bind_text(stmt, 1, username, -1, SQLITE_STATIC) != SQLITE_OK) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to bind text: %s", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (sqlite3_step(stmt) != SQLITE_DONE) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to execute statement: %s", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        close_sqlite_db(db);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    ap_set_content_type(r, "text/plain");
    ap_rprintf(r, "User %s remove from the database", username);

    sqlite3_finalize(stmt);
    close_sqlite_db(db);
    return OK;
}

static int capsvm_handler(request_rec *r) {
    if (strcmp(r->handler, "capsvm_api")) {
        return DECLINED;
    }

    if (r->method_number != M_POST) {
        return HTTP_METHOD_NOT_ALLOWED;
    }

    if (strcmp(r->uri, "/capsvm_api/getgroup/") == 0) {
        return getgroup_handler(r);
    } else if (strcmp(r->uri, "/capsvm_api/management/adduser/") == 0) {
        return adduser_handler(r);
    } else if (strcmp(r->uri, "/capsvm_api/management/modifyuser/") == 0) {
        return modifyuser_handler(r);
    } else if (strcmp(r->uri, "/capsvm_api/management/removeuser/") == 0) {
        return deleteuser_handler(r);
    } else {
        return HTTP_NOT_FOUND;
    }

    return OK;
}

static const authn_provider capsvm_auth_provider = {
    &capsvm_check_password,
    NULL
};

static const char *set_auth_basic_provider(cmd_parms *cmd, void *config, const char *arg) {
    if (strcasecmp(arg, "capsvm_api_module") != 0) {
        return "Invalid provider name";
    }
    return NULL;
}

static const char *set_db_path(cmd_parms *cmd, void *config, const char *arg) {
    db_path = apr_pstrdup(cmd->pool, arg);
    if (db_path == NULL) {
        return "Failed to copy db path";
    }
    return NULL;
}

static const command_rec capsvm_api_cmds[] = {
    AP_INIT_TAKE1("AuthBasicProvider", set_auth_basic_provider, NULL, OR_AUTHCFG, "Set the authentication provider for Basic authentication"),
    AP_INIT_TAKE1("SetDbPAth", set_db_path, NULL, OR_AUTHCFG, "Set the path to the sqlite database"),
    {NULL}
};

static void capsvm_api_register_hooks(apr_pool_t *p) {
    ap_hook_handler(capsvm_handler, NULL, NULL, APR_HOOK_MIDDLE);
    ap_register_auth_provider(p, AUTHN_PROVIDER_GROUP, "capsvm_api_module", AUTHN_PROVIDER_VERSION, &capsvm_auth_provider, AP_AUTH_INTERNAL_PER_CONF);
}

module AP_MODULE_DECLARE_DATA capsvm_api_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    capsvm_api_cmds,       /* table of config file commands       */
    capsvm_api_register_hooks  /* register hooks                      */
};
